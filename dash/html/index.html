<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">
    <title>Tile Dash</title>
    <link rel="stylesheet" href="css/bulma.css">
    <script src="/socket.io/socket.io.js"></script>
    <script defer src="https://use.fontawesome.com/releases/v5.0.0/js/all.js"></script>
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', () => {
            const ZOOM_LEVEL = .75; // Must match body's zoom CSS level

            const elems = {};
            let tileNodes = document.querySelectorAll(
                '#clock-tile, #thermostat-tile, #system-tile, #weather-tile, #livingroom-tile, #bedroom-tile');
            if (tileNodes) {
                tileNodes.forEach((node, index, list) => {
                    switch (node.id) {
                        case 'clock-tile':
                            elems.clock = {
                                time: node.querySelector('#clock-time'),
                                day: node.querySelector('#clock-day'),
                                date: node.querySelector('#clock-date')
                            };
                            break;
                        case 'thermostat-tile':
                            elems.thermostat = node.querySelector('#thermostat_value');
                            break;
                        case 'livingroom-tile':
                        case 'bedroom-tile':
                            let name = node.id.replace('-tile', '');
                            elems[name] = { title: node.querySelector(`${name}-title`) };
                            let buttons = node.querySelectorAll(`[data-group=${name}] p`);
                            buttons.forEach((switchNode, switchIndex, switchList) => {
                                let action = switchNode.dataset.action;
                                elems[name][action] = { label: switchNode.querySelector('span') };
                                let icon = switchNode.querySelector('i, svg');
                                if (icon) {
                                    elems[name][action].iconParent = icon.parentNode;
                                }
                            });
                            break;
                        case 'system-tile':
                        case 'weather-tile':
                            //
                    }
                });
            }

            class Clock {
                constructor(seconds = false, militaryTime = false, callback = null) {
                    this._time = null;
                    this._day = null;
                    this._date = null;

                    this._timeOptions = {
                        hour12: !militaryTime,
                        hour: '2-digit',
                        minute: '2-digit'
                    };
                    this.seconds = seconds;

                    this._dayOptions = {
                        weekday: 'long'
                    };
                    this._dateOptions = {
                        day: 'numeric',
                        month: 'short',
                        year: 'numeric'
                    };

                    this._callback = null;
                    if (callback) {
                        this.callback = callback;
                    }
                    this._timeoutJob = null;
                }

                start(callback) {
                    if (callback) {
                        this.callback = callback;
                    }
                    if (this._callback === null) {
                        throw "Clock callback required to start ticking.";
                    }
                    if (this._timeoutJob === null) {
                        let timeout = (this._seconds) ? 1000 : 60000;
                        this._timeoutJob = setInterval(Clock._onTick(this), timeout);
                        Clock._onTick(this)();
                    }
                }

                stop() {
                    if (this._timeoutJob !== null) {
                        clearInterval(this._timeoutJob);
                        this._timeoutJob = null;
                    }
                }

                static _onTick(parent) {
                    return () => {
                        let now = new Date();
                        parent._time = now.toLocaleTimeString('en-US', parent._timeOptions);
                        let update = { time: parent._time };

                        // TODO: check if date needs updating
                        parent._day = now.toLocaleDateString('en-US', parent._dayOptions);
                        update.day = parent._day;
                        parent._date = now.toLocaleDateString('en-US', parent._dateOptions);
                        update.date = parent._date;

                        parent._callback(update);
                    };
                }

                get time() {
                    return {
                        time: this._time,
                        day: this._day,
                        date: this._date
                    };
                }

                set callback(callback) {
                    if (!(callback instanceof Function)) {
                        throw "Callback must be a function";
                    }
                    this._callback = callback;
                }

                set seconds(showSeconds) {
                    // TODO: Update any existing timeoutInterval
                    this._seconds = showSeconds;
                    if (showSeconds) {
                        this._timeOptions.second = '2-digit';
                    } else {
                        delete this._timeOptions.second;
                    }
                }
            }

            class TapManager {
                constructor() {
                    // TODO: with only one `touching` does this limit to one button press at a time? is that desirable?
                    this.touching = false;
                    this.timeout = 500; // 1000?
                }

                get onTap() {
                    return this._onTap;
                }

                set onTap(callback) {
                    this._onTap = callback;
                }

                get onTapAndHold() {
                    return this._onTapAndHold;
                }

                set onTapAndHold(callback) {
                    this._onTapAndHold = callback;
                }

                static touches(touch, element) {
                    let {top, bottom, left, right} = element.getBoundingClientRect();
                    let {clientX, clientY} = touch;

                    return (clientX >= left * ZOOM_LEVEL && clientX <= right * ZOOM_LEVEL)
                        && (clientY >= top * ZOOM_LEVEL && clientY <= bottom * ZOOM_LEVEL);
                }

                register(button) {
                    button.onclick = (event) => {
                        event.preventDefault();
                        console.log('onclick');
                    };
                    button.ontouchstart = this._handleTouchStart(button);
                    button.ontouchend = this._handleTouchEnd(button);
                    button.ontouchmove = this._handleTouchMove(button);
                    button.ontouchcancel = this._handleTouchCancel(button);
                }

                // unregister(button) {
                //     // TODO: button.removeEventListener
                //     // TODO: register(btn) will need to store the generated EventHandler functions to be able to remove
                //     // TODO: OR could button.ontouchstart = undefined; work? test this.
                // }

                _handleTouchStart(button) {
                    return (event) => {
                        event.preventDefault();
                        button.classList.add('is-hovered');
                        this.touching = true;
                        button.tapMgrTimeout = Date.now();
                    }
                }

                _handleTouchEnd(button) {
                    let parent = this;
                    return (event) => {
                        event.preventDefault();
                        if (!this.touching) {
                            button.classList.remove('is-hovered');
                            delete button.tapMgrTimeout;
                            return;
                        }

                        button.classList.add('is-active');
                        setTimeout(() => {
                            button.classList.remove('is-hovered', 'is-active');
                        }, 50);

                        let now = Date.now();
                        // console.log(`now: ${now} - timeout: ${button.tapMgrTimeout} = ${(now - button.tapMgrTimeout)}`);
                        let delay = now - button.tapMgrTimeout;
                        // console.log(`Delay: ${delay}`);
                        if (delay >= parent.timeout) {
                            if (parent.onTapAndHold) {
                                parent.onTapAndHold(button);
                            }
                        } else {
                            if (parent.onTap) {
                                parent.onTap(button);
                            }
                        }
                        delete button.tapMgrTimeout;
                    }
                }

                _handleTouchMove(button) {
                    return (event) => {
                        // todo: test preventDefault for weird behavior
                        // event.preventDefault();

                        let touches = TapManager.touches(event.touches[0], button);
                        if (touches !== this.touching) {
                            this.touching = touches;
                            if (touches) {
                                button.classList.add('is-hovered');
                            } else {
                                button.classList.remove('is-hovered');
                            }
                        }
                    }
                }

                _handleTouchCancel(button) {
                    return (event) => {
                        // console.log(event);
                        this.touching = false;
                        event.preventDefault();
                        button.classList.remove('is-hovered', 'is-active');
                        delete button.tapMgrTimeout;
                        return true;
                    }
                }
            }

            const clock = new Clock();
            clock.start((time) => {
                elems.clock.time.innerText = time.time;
                if (time.day) {
                    elems.clock.day.innerText = time.day;
                }
                if (time.date) {
                    elems.clock.date.innerText = time.date;
                }
            });

            const socket = io();
            const tapMgr = new TapManager();
            tapMgr.onTap = handleTap;
            tapMgr.onTapAndHold = handleTapAndHold;

            function handleTap(button) {
                let options = {
                    action: button.dataset.action,
                    group: button.parentElement.dataset.group
                };
                switch (options.action) {
                    case 'toggle':
                    case 'presets':
                        options.type = options.action;
                        break;
                    case 'up':
                    case 'down':
                        options.type = 'dimmer';
                        break;
                    default:
                        return;
                }
                socket.emit('lightswitch', options);
            }

            function handleTapAndHold(button) {
                let options = {
                    action: button.dataset.action,
                    group: button.parentElement.dataset.group
                };
                switch (options.action) {
                    case 'up':
                        options.type = 'dimmer';
                        options.action = 'top';
                        break;
                    case 'down':
                        options.type = 'dimmer';
                        options.action = 'bottom';
                        break;
                    case 'toggle':
                        options.type = 'toggle';
                        options.action = 'reset';
                        break;
                    case 'presets':
                        options.type = 'presets';
                        options.action = 'down';
                        break;
                    default:
                        return;
                }
                socket.emit('lightswitch', options);
            }

            function updateLightswitch(data) {
                let {group, name, argument, item} = data;
                if (item.changed || argument === 'request') {
                    let elem = elems[group][name];
                    // TODO: cycle through all buttins in group for update? PRESETS doesn't update an OFF switch.
                    switch (name) {
                        case 'toggle':
                            // TODO: This is causing UI bugs on the RasPi hardware
                            let icon = elem.iconParent.querySelector('svg');
                            // let { any_on, all_on } = item.state.attributes;
                            // TODO: Add a half-overlay of lightbulb when (any_on && !all_on)
                            // TODO~: It looks like these values are not the updated values. Should switch.js request up-to-date information right away?
                            let on = item.action.attributes.on;
                            icon.dataset.prefix = on ? 'fas' : 'far';
                            elem.label.innerText = on ? 'ON' : 'OFF';
                            break;
                        case 'dimmer':
                        case 'presets':
                        default:
                            break;
                    }
                }
            }

            let buttons = document.querySelectorAll('article.ui-btn .button');
            for (let i = 0; i < buttons.length; i++) {
                let button = buttons[i];
                tapMgr.register(button);
            }

            socket.on('connect', () => {
                console.log('socket.io READY');
                socket.emit('thermostat');  // Request thermostat reading
            });

            socket.on('features', (data) => {
                console.log(`Features: ${JSON.stringify(data)}`);
                let names;
                for (let i in names = Object.getOwnPropertyNames(data)) {
                    let name = names[i];
                    if (data[name]) {
                        socket.emit(name, { action: 'request' });
                    }
                }
            });

            socket.on('updateLightswitch', (data) => {
                updateLightswitch(data);
            });

            socket.on('updateThermostat', (data) => {
                // TODO: data verification and console logging on update
                elems.thermostat.innerText = data.temperatureFormatted;
            });
        });
    </script>
    <style type="text/css">
        body {
            /* Scaling base interface size */
            zoom: 75%;
        }

        .section {
            padding: 32px;
        }

        article.ui-label {
            padding-right: 32px;
            text-align: center;
        }

        article.ui-btn {
            padding: 0px;
        }

        article.ui-btn p {
            display: grid;

            width: 100% !important;
            height: auto !important;

            padding: 0px;
            margin: 0px !important;
        }

        article.ui-btn p svg {
            margin: 0 auto;
        }

        article.ui-btn p:only-child {
            padding-bottom: 10px !important;
        }

        article.ui-btn p:only-child svg,
        article.ui-btn p:nth-child(2) svg {
            margin: 10px auto;
        }
    </style>
</head>
<body>
<section class="section">
    <div class="tile is-ancestor">
        <div class="tile is-vertical is-6">
            <div class="tile">
                <div class="tile is-vertical">
                    <div class="tile is-parent" id="clock-tile">
                        <article class="tile is-child notification is-warning">
                            <p class="title" id="clock-time">3:30 PM</p>
                            <p class="subtitle">
                                <span id="clock-day">Wednesday</span>
                                <br />
                                <span id="clock-date">Jan 31 2018</span>
                            </p>
                        </article>
                    </div>
                    <div class="tile is-parent" id="thermostat-tile">
                        <article class="tile is-child notification is-warning">
                            <p class="subtitle">Inside</p>
                            <p class="title" id="thermostat_value">--</p>
                            <p class="subtitle">(Inside case, currently unvented)</p>
                        </article>
                    </div>
                </div>
                <div class="tile is-parent" id="system-tile">
                    <article class="tile is-child notification is-info">
                        <p class="title">System Panel</p>
                        <p class="subtitle">System stats, button for system settings</p>
                    </article>
                </div>
            </div>
            <div class="tile is-parent" id="weather-tile">
                <article class="tile is-child notification is-danger">
                    <p class="title">Weather Forecast</p>
                    <p class="subtitle">Now / Today / Tomorrow ( / Next?)</p>
                    <div class="content">
                        <!-- Content -->
                    </div>
                </article>
            </div>
        </div>
        <div class="tile is-vertical is-3">
            <div class="tile is-child" id="livingroom-tile">
                <div class="tile is-parent">
                    <article class="tile is-child notification is-primary ui-label">
                        <div class="title is-4" id="livingroom-title">Living Room</div>
                    </article>
                </div>
                <div class="tile is-parent">
                    <article class="tile is-child notification is-primary ui-btn" data-group="livingroom">
                        <p class="button icon is-large is-primary" data-action="up">
                            <i class="fas fa-3x fa-chevron-up"></i>
                        </p>
                        <p class="button is-large is-primary title icon" data-action="toggle">
                            <i class="far fa-3x fa-lightbulb"></i>
                            <span>OFF</span>
                        </p>
                        <p class="button is-large is-primary" data-action="down">
                            <i class="fas fa-3x fa-chevron-down"></i>
                        </p>
                    </article>
                </div>
                <div class="tile is-parent">
                    <article class="tile is-child notification is-primary ui-btn" data-group="livingroom">
                        <p class="button is-large is-primary title icon" data-action="presets">
                            <i class="fas fa-3x fa-adjust"></i>
                            <span>PRESETS</span>
                        </p>
                    </article>
                </div>
            </div>
        </div>
        <div class="tile is-vertical is-3">
            <div class="tile is-child" id="bedroom-tile">
                <div class="tile is-parent">
                    <article class="tile is-child notification is-primary ui-label">
                        <div class="title is-4" id="bedroom-title">Bedroom</div>
                    </article>
                </div>
                <div class="tile is-parent">
                    <article class="tile is-child notification is-primary ui-btn" data-group="bedroom">
                        <p class="button icon is-large is-primary" data-action="up">
                            <i class="fas fa-3x fa-chevron-up"></i>
                        </p>
                        <p class="button is-large is-primary title icon" data-action="toggle">
                            <i class="far fa-3x fa-lightbulb"></i>
                            <span>OFF</span>
                        </p>
                        <p class="button is-large is-primary" data-action="down">
                            <i class="fas fa-3x fa-chevron-down"></i>
                        </p>
                    </article>
                </div>
                <div class="tile is-parent">
                    <article class="tile is-child notification is-primary ui-btn" data-group="bedroom">
                        <p class="button is-large is-primary title icon" data-action="presets">
                            <i class="fas fa-3x fa-adjust"></i>
                            <span>PRESETS</span>
                        </p>
                    </article>
                </div>
            </div>
        </div>
    </div>
</section>
</body>
</html>